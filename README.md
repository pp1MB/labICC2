# SCC0220 - Laboratório de Introdução à Ciência da Computação II
A proposta da disciplina é a implementação de algoritmos variados e a comparação entre eles para cálculo de maior eficiência.
- Todos os trabalhos possuem um relatório detalhando o processo de construção dos códigos e métodos de avaliação. Abaixo está um resumo de cada trabalho.

## Trabalho 1 - Multiplicação
> Faça duas implementações, uma utilizando a multiplicação convencional e outra utilizando o algoritmo de Karatsuba. Na conclusão lembre-se que o método convencional é $O(n^{2})$ e o algoritmo de Karatsuba $O(n^{log_23}) \approx O(n^{1.58}).$

## Trabalho 2 - Exponenciação
> Implemente a exponenciação de duas formas: uma iterativa $O(n)$ e outra utilizando o método de divisão e conquista (exponenciação rápida) $O(\log n)$.

## Trabalho 3 - Seleção
> Implemente o algoritmo de ordenação por seleção $O(n^{2})$ e Shell Sort $O(n^{3/2})$ no registro de jogador. Utilize um TAD de pilha para a implementação do algoritmo de ordenação por seleção. Ordenar no formato nome nota `nome nota`, onde nome é uma string de no máximo 50 caracteres e nota um inteiro entre 0 e 120. Se houver dois jogadores com a mesma nota, utilize a ordem lexicográfica de seus nomes como critério de desempate.

## Trabalho 4 - Notáveis
> Leia um arquivo planilha .csv das notas de uma turma de alunos e imprima os `k` alunos com maior aumento de nota.

## Trabalho 5 - Bubble and Quick
> Implemente o BubbleSort $O(n^{2})$ e o QuickSort $O(n log n)$ para ordenar pratos de um restaurante a partir de tempo e prioridade.

## Trabalho 6 - A outra pilha
> Implemente o MergeSort $O(n log n)$ e o HeapSort $O(n log n)$ para ordenar pratos de um restaurante a partir de tempo e prioridade.

## Trabalho 7 - A outra pilha
> Implete o RadixSort $O(n)$, nesse caso, e o StoogeSort $O(n^{2.7})$ para ordenar cartas de baralho.

## Trabalho 8 - Buscando problemas
> Implemente a busca binária $O(log n)$ para buscar cartas danificadas em um baralho e compare com a busca sequencial $O(n)$.

## Trabalho 9 - O melhor caminho
> Implemente a árvore binária de busca e compare sua eficiência de busca $O(log n)$ com uma busca linear, como a busca em profundidade ou a busca em largura $O(n)$.

## Trabalho 10 - MSC
> Implemente o algoritmo de Máxima Subsequência Consecutiva, uma implementação utilizando HashMap e outra usando ordenação.

## Trabalho 11 - Tour
> Simule um grafo e percorra com determinado número de passos.
